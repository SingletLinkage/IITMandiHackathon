{
    "title": "Write Wrapper S-Function and TLC Files",
    "introduction": "Create S-functions that work seamlessly with the SimulinkÂ® and code generator products by using the wrapper concept. You can:",
    "chunks": [
        {
            "heading": "MEX S-Function Wrapper",
            "content": "Creating S-functions by using an S-function wrapper enables you to insert C/C++ code algorithms in Simulink models and the generated code with little or no change to your original C/C++ function. A MEX S-function wrapper is an S-function that calls code, which resides in another module.\n\nNoteUse a MEX S-function wrapper only in the MATLABÂ® version in which you created the wrapper.\n\nSuppose that you have an algorithm (that is, a C function) called my_alg that resides in the file my_alg.c. You can integrate my_alg into a Simulink model by creating a MEX S-function wrapper (for example, wrapsfcn.c). A Simulink model can then call my_alg from an S-Function block. The Simulink S-function contains a set of empty functions that the Simulink engine requires for various API related purposes. For example, although only mdlOutputs calls my_alg, the engine calls mdlTerminate, even though this S-function routine performs no action.\n\nYou can embed the call to my_alg in the generated code by creating a TLC S-function wrapper (for example, wrapsfcn.tlc). You can eliminate the empty function calls. You can avoid the overhead of executing the mdlOutputs function and you can then eliminate the my_alg function.\n\nWrapper S-functions are useful when you are creating algorithms that are procedural or when you are integrating legacy code into a Simulink model. If you want to create code that is:\n\nInterpretive in nature (that is, highly parameterized by operating modes) Heavily optimized (that is, no extra tests to decide what mode the code is operating in)\n\nthen you must create a fully inlined TLC file for your S-function.\n\nThe next figure shows the wrapper S-function concept.\n\nUsing an S-function wrapper to import algorithms into your Simulink model means that the S-function serves as an interface that calls your C/C++ algorithms from mdlOutputs. You can quickly integrate large standalone C/C++ programs into your model without having to change the code.\n\nThis sample model includes an S-function wrapper.\n\nTwo files are associated with the wrapsfcn block: the S-function wrapper and the C/C++ code that contains the algorithm. The first three statements:\n\nDefine the name of the S-function (what you enter in the Simulink S-Function block dialog box).Specify that the S-function is using the level 2 format.Provide access to the SimStruct data structure. SimStruct contains pointers to data used during simulation and code generation and defines macros that store data in and retrieve data from the SimStruct.\n\n#define S_FUNCTION_NAME wrapsfcn #define S_FUNCTION_LEVEL 2 #include \"simstruc.h\" extern real_T my_alg(real_T u); /* Declare my_alg as extern */ /* * mdlInitializeSizes - initialize the sizes array */ static void mdlInitializeSizes(SimStruct *S) { ssSetNumSFcnParams( S, 0); /*number of input arguments*/ if (!ssSetNumInputPorts(S, 1)) return; ssSetInputPortWidth(S, 0, 1); ssSetInputPortDirectFeedThrough(S, 0, 1); if (!ssSetNumOutputPorts(S,1)) return; ssSetOutputPortWidth(S, 0, 1); ssSetNumSampleTimes( S, 1); } /* * mdlInitializeSampleTimes - indicate that this S-function runs Â *Â at the rate of the source (driving block) */ static void mdlInitializeSampleTimes(SimStruct *S) { ssSetSampleTime(S, 0, INHERITED_SAMPLE_TIME); ssSetOffsetTime(S, 0, 0.0); } /* * mdlOutputs - compute the outputs by calling my_alg, which *Â resides in another module, my_alg.c */ static void mdlOutputs(SimStruct *S, int_T tid) { InputRealPtrsType uPtrs = ssGetInputPortRealSignalPtrs(S,0); real_T *y = ssGetOutputPortRealSignal(S,0); Â Â Â Â *y = my_alg(*uPtrs[0]); /* Call my_alg in mdlOutputs */ } /* * mdlTerminate - called when the simulation is terminated. */ static void mdlTerminate(SimStruct *S) { } #ifdef MATLAB_MEX_FILE /* Is this file being compiled as a MEX-file? */ #include \"simulink.c\" /* MEX-file interface mechanism */ #else #include \"cg_sfun.h\" /* Code generation registration function */ #endif\n\nFor more information, see Templates for C S-Functions.\n\nThe S-function routine mdlOutputs contains a function call to my_alg, which is the C function containing the algorithm that the S-function performs. For my_alg.c, the code is:\n\n#ifdef MATLAB_MEX_FILE #include \"tmwtypes.h\" #else #include \"rtwtypes.h\" #endif real_T my_alg(real_T u) { return(u * 2.0); }\n\nFor more information, see Manage Build Process File Dependencies.\n\nThe wrapper S-function wrapsfcn calls my_alg, which computes u * 2.0. To build wrapsfcn.mex, use this command:\n\nmex wrapsfcn.c my_alg.c"
        },
        {
            "heading": "TLC S-Function Wrapper",
            "content": "A TLC S-function wrapper is a TLC file that specifies how the code generator calls your code. For example, you can inline the call to my_alg in the mdlOutputs section of the generated code. In the MEX S-Function Wrapper example, the call to my_alg is embedded in the mdlOutputs section as:\n\n*y = my_alg(*uPtrs[0]);\n\nWhen you are creating a TLC S-function wrapper, the goal is to embed the same type of call in the generated code.\n\nLook at how the code generator executes S-functions that are not inlined. A noninlined S-function is identified by the absence of the file sfunction.tlc and the existence of sfunction.mex. When generating code for a noninlined S-function, the code generator produces a call to mdlOutputs through a function pointer that, in this example, then calls my_alg.\n\nThe wrapper example contains one S-function, wrapsfcn.mex. You must compile and link an additional module, my_alg, with the generated code. At the MATLAB command prompt, enter:\n\nset_param('wrapper/S-Function','SFunctionModules','my_alg')"
        },
        {
            "heading": "Code Overhead for Noninlined S-Functions",
            "content": "The code generated when using grt.tlc as the system target file without wrapsfcn.tlc is:\n\n<Generated code comments for wrapper model with noninlined wrapsfcn S-function> #include <math.h> #include <string.h> #include \"wrapper.h\" #include \"wrapper.prm\" /* Start the model */ void mdlStart(void) { /* (start code not required) */ } /* Compute block outputs */ void mdlOutputs(int_T tid) { /* Sin Block: <Root>/Sin */ rtB.Sin = rtP.Sin.Amplitude * sin(rtP.Sin.Frequency * ssGetT(rtS) + rtP.Sin.Phase); /* Level2 S-Function Block: <Root>/S-Function (wrapsfcn) */ Â { /* Noninlined S-functions create a SimStruct object and * generate a call to S-function routine mdlOutputs */ SimStruct *rts = ssGetSFunction(rtS, 0); sfcnOutputs(rts, tid); } /* Outport Block: <Root>/Out */ rtY.Out = rtB.S_Function; } /* Perform model update */ void mdlUpdate(int_T tid) { /* (update code not required) */ } /* Terminate function */ void mdlTerminate(void) { /* Level2 S-Function Block: <Root>/S-Function (wrapsfcn) */ Â Â { /* Noninlined S-functions require a SimStruct object and * the call to S-function routine mdlTerminate */ SimStruct *rts = ssGetSFunction(rtS, 0); sfcnTerminate(rts); } } #include \"wrapper.reg\" /* [EOF] wrapper.c */\n\nThe wrapper.reg generated file contains the initialization of the SimStruct for the wrapper S-Function block. There is one child SimStruct for each S-Function block in your model. You can significantly reduce this overhead by creating a TLC wrapper for the S-function."
        },
        {
            "heading": "Inline a Wrapper S-Function",
            "content": "The generated code makes the call to your S-function, wrapsfcn.c, in mdlOutputs by using this code:\n\nSimStruct *rts = ssGetSFunction(rtS, 0); sfcnOutputs(rts, tid);\n\nThis call has computational overhead associated with it. The Simulink engine creates a SimStruct data structure for the S-Function block. The code generator constructs a call through a function pointer to execute mdlOutputs, then mdlOutputs calls my_alg. By inlining the call to your C/C++ algorithm, my_alg, you can eliminate both the SimStruct and the extra function call, thereby improving the efficiency and reducing the size of the generated code.\n\nInlining a wrapper S-function requires an sfunction.tlc file for the S-function. The TLC file must contain the function call to my_alg. The figure shows the relationships between the algorithm, the wrapper S-function, and the sfunction.tlc file.\n\nTo inline the call to my_alg, place your function call in an sfunction.tlc file with the same name as the S-function (in this example, wrapsfcn.tlc). The Target Language Compiler overrides the default method of placing calls to your S-function in the generated code.\n\nThis code is the TLC file wrapsfcn.tlc that inlines wrapsfcn.c:\n\n%% File : wrapsfcn.tlc %% Abstract: %% Example inlined tlc file for S-function wrapsfcn.c %% %implements \"wrapsfcn\" \"C\" %% Function: BlockTypeSetup ==================================================== %% Abstract: %% Create function prototype in model.h as: %% Â Â Â Â Â \"extern real_T my_alg(real_T u);\" %% %function BlockTypeSetup(block, system) void %openfile buffer Â Â Â Â extern real_T my_alg(real_T u); /* This line is placed in wrapper.h */ %closefile buffer %<LibCacheFunctionPrototype(buffer)> %endfunction %% BlockTypeSetup %% Function: Outputs =========================================================== %% Abstract: %% y = my_alg( u ); %% %function Outputs(block, system) Output /* %<Type> Block: %<Name> */ %assign u = LibBlockInputSignal(0, \"\", \"\", 0) %assign y = LibBlockOutputSignal(0, \"\", \"\", 0) %% PROVIDE THE CALLING STATEMENT FOR \"algorithm\" %% The following line is expanded and placed in mdlOutputs within wrapper.c Â Â %<y> = my_alg(%<u>); %endfunction %% Outputs\n\nThe first section of this code inlines the wrapsfcn S-Function block and generates the code in C:\n\n%implements \"wrapsfcn\" \"C\"\n\nThe next task is to inform the code generator that the routine my_alg must be declared as external in the generated wrapper.h file for any wrapsfcn S-Function blocks in the model. Do this declaration once for all wrapsfcn S-Function blocks by using the BlockTypeSetup function. In this function, you direct the Target Language Compiler to create a buffer and cache the my_alg as extern in the wrapper.h generated header file.\n\nThe final step is the inlining of the call to the function my_alg. The Outputs function inlines the call. In this function, you access the block input and output and place a direct call to my_alg. The call is embedded in wrapper.c."
        },
        {
            "heading": "The Inlined Code",
            "content": "The code generated when you inline your wrapper S-function is similar to the default generated code. The mdlTerminate function does not contain a call to an empty function and the mdlOutputs function now directly calls my_alg.\n\nvoid mdlOutputs(int_T tid) { /* Sin Block: <Root>/Sin */ rtB.Sin = rtP.Sin.Amplitude * sin(rtP.Sin.Frequency * ssGetT(rtS) + rtP.Sin.Phase); /* S-Function Block: <Root>/S-Function */ Â Â rtB.S_Function = my_alg(rtB.Sin); /* Inlined call to my_alg */ Â Â /* Outport Block: <Root>/Out */ rtY.Out = rtB.S_Function; }\n\nwrapper.reg does not create a child SimStruct for the S-function because the generated code is calling my_alg directly, eliminating over 1 KB of memory usage."
        }
    ],
    "link": "https://in.mathworks.com/help/rtw/ug/write-wrapper-s-function-and-tlc-files.html",
    "images": [
        "https://in.mathworks.com/help/rtw/ug/sfunction_wrapper_concept_block_diagram_11a.png",
        "https://in.mathworks.com/help/rtw/ug/ex_mexsfuncwrap_model.png",
        "https://in.mathworks.com/help/rtw/ug/inlining_alg_with_tlc_11a.png"
    ]
}