{
    "title": "Control Library Location and Naming During Build",
    "introduction": "When you generate precompiled, non-precompiled, and model reference libraries, you can control the library location and library name by using configuration parameters. These parameters control values in generated makefiles during model builds:",
    "chunks": [
        {
            "heading": "Library Control Parameters",
            "content": "Use the library control parameters to:\n\nSpecify the location of precompiled libraries, such as blockset libraries or the SimulinkÂ® Coderâ¢ block library. Typically, a target has cross-compiled versions of these libraries and places them in a target-specific folder.Control the suffix applied to library file names (for example, _target.a or _target.lib).\n\nTargets can set the parameters inside the system target file (STF) select callback. For example:\n\nfunction mytarget_select_callback_handler(varargin) hDig=varargin{1}; hSrc=varargin{2}; slConfigUISetVal(hDig, hSrc, 'TargetPreCompLibLocation',... 'c:\\mytarget\\precomplibs'); slConfigUISetVal(hDig, hSrc, 'TargetLibSuffix',... '_target.library');\n\nThe TMF has corresponding expansion tokens:\n\n|>EXPAND_LIBRARY_LOCATION<| |>EXPAND_LIBRARY_SUFFIX<|\n\nAlternatively, you can use a call to the set_param function. For example:\n\nset_param(model,'TargetPreCompLibLocation',... 'c:\\mytarget\\precomplibs');\n\nNoteIf your model contains referenced models, you can use the make option USE_MDLREF_LIBPATHS to control whether libraries used by the referenced models are copied to the build folder of the parent model. For more information, see Location of Model Reference Libraries."
        },
        {
            "heading": "Identify Library File Type for Toolchain Approach",
            "content": "The toolchain approach for model builds does not use the value of the TargetLibSuffix configuration parameter to select the library file name suffix and extension.\n\nWith the toolchain approach, the final binary name is composed of the modelname, the compilername, and the extension provided by the build tool description in the toolchain definition:\n\nmodel_compilername.extension\n\nYou can identify the static library file name extension from the build tool description in the toolchain definition. To get this information for the default toolchain, use this procedure:\n\nGet the default toolchain name. For example, enter:tc_name = coder.make.getDefaultToolchain()Get the default toolchain handle. For example, enter:tc = coder.make.getToolchainInfoFromRegistry(tc_name)Get the handle to the toolchain object. For example, enter:tool_archiver = tc.getBuildTool('Archiver');Get the extension. For example, enter:ext_archiver = tool_archiver.getFileExtension('Static Library');\n\nNote If you do not set the TargetLibSuffix parameter, template makefile and toolchain approaches produce the same static library file name extension."
        },
        {
            "heading": "Specify the Location of Precompiled Libraries",
            "content": "Use the TargetPreCompLibLocation configuration parameter to:\n\nOverride the precompiled library location specified in the rtwmakecfg.m file (see Use rtwmakecfg.m API to Customize Generated Makefiles for details)Precompile and distribute target-specific versions of product libraries (for example, the DSP System Toolboxâ¢ product)\n\nFor a precompiled library, such as a blockset library or the Simulink Coder block library, the location specified in rtwmakecfg.m is typically a location specific to the blockset or the Simulink Coder product. The code generator expects that the library exists in this location and links against the library during builds.\n\nFor some applications, such as custom targets, it is preferable to locate the precompiled libraries in a target-specific or other alternate location rather than in the location specified in rtwmakecfg.m. For a custom target, the code generator expects that the target-specific cross-compiler creates the library, and you place the library in the target-specific location. Compile and place libraries supported by the target in the target-specific location, so they can be used during the build process.\n\nYou can set up the TargetPreCompLibLocation parameter in its select callback. The path that you specify for the parameter must be a fully qualified, absolute path to the library location. Relative paths are not supported. For example:\n\nslConfigUISetVal(hDlg, hSrc, 'TargetPreCompLibLocation',... 'c:\\mytarget\\precomplibs');\n\nAlternatively, you set the parameter with a call to the set_param function. For example:\n\nset_param(model,'TargetPreCompLibLocation',... 'c:\\mytarget\\precomplibs');\n\nDuring makefile generation, the build process replaces the tokens with the location from the rtwmakecfg.m file. For example, if the library name in the rtwmakecfg.m file is 'rtwlib', the template makefile build approach expands the token from:\n\nLIBS += |>EXPAND_LIBRARY_LOCATION<|\\|>EXPAND_LIBRARY_NAME<|\\ _target.library\n\nto:\n\nLIBS += c:\\mytarget\\precomplibs\\rtwlib_target.library\n\nBy default, TargetPreCompLibLocation is an empty character vector. The build process uses the location in rtwmakecfg.m for the token replacement."
        },
        {
            "heading": "Location of Model Reference Libraries",
            "content": "The build process assigns a path such as ../slprj/grt/sub/sub_rtwlib.lib to MODELREF_LINK_LIBS. The build process uses the path to gain access to the library file at link time."
        },
        {
            "heading": "Control the Suffix Applied to Library File Names",
            "content": "With the template makefile approach for model builds, use the TargetLibSuffix configuration parameter to control the suffix applied to library names (for example, _target.lib or _target.a). The specified suffix scheme must include a period (.). You can apply TargetLibSuffix to the following libraries:\n\nLibraries on which a target depends, as specified in the rtwmakecfg.m API. You can use TargetLibSuffix to change the suffix of both precompiled and non-precompiled libraries configured from the rtwmakecfg API. For details, see Use rtwmakecfg.m API to Customize Generated Makefiles.In this case, a target can set the parameter in its select callback. For example: slConfigUISetVal(hDlg, hSrc, 'TargetLibSuffix',... '_target.library');Alternatively, you can use a call to the set_param function. For example:set_param(model,'TargetLibSuffix','_target.library');During the TMF-to-makefile conversion, the build process replaces the token |>EXPAND_LIBRARY_SUFFIX<| with the specified suffix. For example, if the library name specified in the rtwmakecfg.m file is 'rtwlib', the TMF expands from: LIBS += |>EXPAND_LIBRARY_LOCATION<|\\|>EXPAND_LIBRARY_NAME<|\\ |>EXPAND_LIBRARY_SUFFIX<|to: LIBS += c:\\mytarget\\precomplibs\\rtwlib_target.libraryBy default, TargetLibSuffix is set to an empty character vector. In this case, the build process replaces the token |>EXPAND_LIBRARY_SUFFIX<| with an empty character vector.Model libraries created with model reference. For these cases, associated makefile variables do not require the |>EXPAND_LIBRARY_SUFFIX<| token. Instead, the build process includes TargetLibSuffix implicitly. For example, for a top model named topmodel with referenced models named refmodel1 and refmodel2, the TMF of the top model is expanded from:MODELLIB = |>MODELLIB<| MODELREF_LINK_LIBS = |>MODELREF_LINK_LIBS<|to:MODELLIB = topmodellib_target.library MODELREF_LINK_LIBS = \\ refmodel1_rtwlib_target.library refmodel2_rtwlib_target.libraryBy default, the TargetLibSuffix parameter is an empty character vector. In this case, the build process chooses a default suffix for these three tokens using a file extension of .lib on WindowsÂ® hosts and .a on UNIXÂ® hosts. For model reference libraries, the default suffix also includes _rtwlib. For example, on a Windows host, the expanded makefile values are:MODELLIB = topmodellib.lib MODELREF_LINK_LIBS = refmodel1_rtwlib.lib refmodel2_rtwlib.lib"
        }
    ],
    "link": "https://in.mathworks.com/help/rtw/ug/controlling-the-location-and-naming-of-libraries-during-the-build-process.html#bqg8123",
    "images": []
}