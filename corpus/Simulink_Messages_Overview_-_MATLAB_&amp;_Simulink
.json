{
    "title": "Simulink Messages Overview",
    "introduction": "Message-based communication is necessary in various applications, such as control system architectures in which centralized architectures are replaced with distributed architectures due to the complexity of the systems. In a distributed architecture, multiple components of the system communicate via a shared network. A distributed architecture has these three elements: Below is an illustration that shows the composition of a distributed architecture and its elements. When modeling such an architecture, you typically model components that are clearly identifiable, reusable, and deployable. To achieve asynchronous event-based communication between components, use message send and receive interfaces. Model the middleware to facilitate the network topology that represents the connectivity of components, such as one-to-many, many-to-one, or many-to-many based on the number of message sending and receiving components. For an example, see Build a Shared Communication Channel with Multiple Senders and Receivers. To learn how to model a distributed architecture, using SimulinkÂ®, SimEventsÂ®, and StateflowÂ®, see the illustration below. The illustration includes two message sending and three message receiving components that are created as referenced models. You can model components with send and receive interfaces using Simulink Send and Receive blocks. If your send and receive interfaces involve states or require decision logic, use a Stateflow chart. You can also model event-driven or message triggered receive interfaces using Message Triggered Subsystem. After you model your components and interfaces: Sine Wave | Send | Receive | Queue | Sequence Viewer",
    "chunks": [
        {
            "heading": "Model Message Send and Receive Interfaces and Generate Code",
            "content": "Let us start by understanding how message blocks work. To create a model that uses messages, use Send blocks to convert data and send messages and Receive blocks to receive and convert messages to data. For a simple example that shows how Send and Receive blocks work, see Animate and Understand Sending and Receiving Messages.\n\nUse Send and Receive blocks to model message send and receive interfaces for your components. For a simple example that shows the basics of creating send and receive interfaces, see Establish Message Send and Receive Interfaces Between Software Components. To learn how to generate code for the same model, see Generate C++ Messages to Communicate Data Between Simulink Components (Embedded Coder).\n\nYou can further modify send and receive interfaces for custom behavior. For example, you can synchronize when a receive interface executes to when data is available. For more information, see Connect Message Receive Interface with Simulink Functions.\n\nAfter modeling, generate code for your send and receive interfaces and connect them to the middleware or an operating system communication API. For an example that generates code for a top model and allows your application to communicate in a distributed system that uses an external message protocol service (for example, DDS, ROS, SOMEIP, or POSIX messages), see Generate C++ Messages to Communicate Data Between Simulink and an Operating System or Middleware (Embedded Coder)."
        },
        {
            "heading": "Model Event-Driven Receive Interfaces",
            "content": "Use Message Triggered Subsystem block to configure your subsystem to be triggered by messages and to respond to events.\n\nWhen you use Message Triggered Subsystem block in scheduled mode, the execution order of the subsystem can be scheduled as aperiodic partitions using the Schedule Editor to model an asynchronous behavior. The subsystems pull and process the data based on a schedule instead of periodic execution. For an example, see Asynchronous Message Handling in Adaptive Cruise Control."
        },
        {
            "heading": "Simulate Middleware Effects on a Distributed Architecture",
            "content": "Use Queue blocks to store, sort and queue messages. The Queue block allows you to specify message storage capacity and the overwriting and sorting policies for message transitions. For a simple example that shows how a Queue block works, see Use a Queue Block to Manage Messages.\n\nYou can also use SimEvents to model and simulate middleware effects on your communication network. Use the blocks provided by the SimEvents library to model message routing, peer-to-peer communication, wireless communication, packet loss, and channel delays. For more information about SimEvents, see Discrete-Event Simulation in Simulink Models (SimEvents).\n\nFor basic communication patterns that can be modeled by SimEvents, see Modeling Message Communication Patterns with SimEvents. You can use combinations of these patterns to create more complex communication behavior. For an example of a system with multiple message sending and receiving components and an ideal shared channel with delay, see Build a Shared Communication Channel with Multiple Senders and Receivers. To see a model with shared wireless channel with channel failure and packet loss, see Model Wireless Message Communication with Packet Loss and Channel Failure.\n\nTo see an example that shows how to model more complex network behavior, such as an Ethernet communication network with CSMA/CD protocol, see Model an Ethernet Communication Network with CSMA/CD Protocol.\n\nNote SimEvents blocks do not support code generation."
        }
    ],
    "link": "https://in.mathworks.com/help/simulink/ug/simulink-messages-overview.html",
    "images": [
        "https://in.mathworks.com/help/simulink/ug/messages_composition_figure.png",
        "https://in.mathworks.com/help/simulink/ug/messages_composition_modeling_figure.png"
    ]
}